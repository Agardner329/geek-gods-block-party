#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     accel,          sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     scissor,       tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    elbow,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    ramp,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

	// Move shoulder. Note, encoder values always negative vs calculation
	// adjust to keep smooth vs shoulder based on deltas - range 1-100
	// Towards Yellow wire on servos is towards 255, to black is to 0

/*ChangeLog:
	teleopFinal8: restriction on newY to prevent hitting the ground (>-15), addition of automatic peg height positioner, autoMove function added to roughly
	position robot in front of pegs quickly, DriveEncReset function added to simplify encoder reset, wait time between array setting commented out to
	expedite program execution
	-WORKS
	*/

#include "JoystickDriver.c"  	//Include file to "handle" the Bluetooth messages.

int elbowPosition;
float turbo;									// normally 0.5. but if button 5 held down on drive joystick, full power to motors
float thetaS; 								// the angle of the shoulder (ALL ANGLES IN DEGREES)
float thetaTE;								// the angle of the elbow
float thetaW; 								// the angle of the wrist
float Pr;											// the hypontenuse of the triangle used in IK
float L1 = 10.75;							// the length of the first arm in inches
float L2 = 9.5;							// the length of the forearm in inches
float xT;											// x position of arm (specifically the wrist/basket)
float yT;											// y position of arm
float sensitivity = 0.004;		// controls how far in inches the wrist will move in a given time interval and controller input of 100
float deltaX;									// for IK, planned change in X based on controller input
float deltaY;									// for IK, planned change in Y based on controller input
float thetaR;									// used in IK calc
float thetaA;									// used in IK calc
float newX;										// for IK, new x position
float newY;										// for IK, new y position
float newThetaS;							// given new XY, calulated new angles
float newThetaTE;
float deltaTE;								// in order to determine rate of joint movement, these values indicate relative velocities
float deltaS;
float shoulderGoal; 	 				// encoder counts to get to shoulder goal
int nme;											// nMotorEncorder[arm] value
float deltaEncoder = 0;
float direction;								// direction the shoulder is moving. Need to slow it down as it approaches 0, but not when moving other direction
float radToDeg = 180/PI;
int countW;
int LeftArray [20];
int RightArray [20];
//bool autoMove;

/*
float degToRad = PI/180;
float radToServo = 255/PI;
float servoToRad = PI/255;
float degToServo = 255/180;
float servoToDeg = 180/255;
bool stableToggle = true;
*/


void DriveEncReset (){
	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;
}

void initializeRobot() {
	//servo[ramp] = 50;
	nMotorEncoder[arm] = 0;
		servoChangeRate[elbow] = 5;					 	//standard servo speed. 10 = default
		servo[elbow] = 160;										//move elbow to deploy position
		while(nMotorEncoder[arm] > -2500)			// move shoulder from rest position to upright. Note, encoder values always negative from start
			motor[arm] = -75;
		while(nMotorEncoder[arm] > -3000)			// move shoulder from rest position to upright. Note, encoder values always negative from start
			motor[arm] = -25;
		while(nMotorEncoder[arm] > -3500)			// move shoulder from rest position to upright. Note, encoder values always negative from start
			motor[arm] = -12;
		wait10Msec(25);											//Waits for servo to right itself, requisite for IK functionality
	for (int ij=1; ij<=20; ij++) {			 			//sets all ints in array to 0
		LeftArray[ij] = 0;
		RightArray[ij] = 0;
	}
	nNoMessageCounterLimit = 325;

}

void Pack() { 														//folds arm back to storage position - first wrist, then elbow then shoulder
	if(joy1Btn(9) && joy1Btn(10)){
		servoChangeRate[wrist] = 5;						//standard servo speed. 10 = default
			servo[wrist] = 0;										//move wrist to storage position
		servoChangeRate[elbow] = 5; 					//standard servo speed. 10 = default
			servo[elbow] = 180;									//move elbow to storage position
		while(nMotorEncoder[arm] < 0)					// move shoulder back to rest position. Note, encoder values always negative from start
			motor[arm] = 25;
		motor[arm] = 0;												// stop shoulder
		StopAllTasks();
	}
}

void RightTurn () {
	DriveEncReset();
	while(nMotorEncoder[left] < 700 && nMotorEncoder[right] > -700) {
		motor[left] = 50;
		motor[right] = -50;
	}
	motor[left] = 0;
	motor[right] = 0;
}

void LeftTurn () {
	DriveEncReset();
	while(nMotorEncoder[left] > -700 && nMotorEncoder[right] < 700) {
		motor[left] = -50;
		motor[right] = 50;
	}
	motor[left] = 0;
	motor[right] = 0;
}

void Forwards () {
	DriveEncReset();
	while(nMotorEncoder[left] < 500 && nMotorEncoder[right] < 500) {
		motor[left] = 50;
		motor[right] = 50;
	}
	motor[left] = 0;
	motor[right] = 0;
}

void Backwards () {
	DriveEncReset();
	while(nMotorEncoder[left] > -1000 && nMotorEncoder[right] > -1000) {
		motor[left] = -50;
		motor[right] = -50;
	}
	motor[left] = 0;
	motor[right] = 0;
}

void driveControl () {
	if(joy2Btn(6))					//if user holding down button, drive motor full speed otherwise 1/2
		turbo=0.781;
	else
		turbo=0.39;

	if (abs(joystick.joy2_y1) < 10)	//null around +- 10 or robot will creep
		LeftArray[1] = 0;
	else
			LeftArray[1]=joystick.joy2_y1*turbo;

	if (abs(joystick.joy2_y2) < 10)
		RightArray[1] = 0;
	else
			RightArray[1] = joystick.joy2_y2*turbo;

	int AverageL=0;
	int AverageR=0;

	for (int ij=1; ij<=19; ij++){
	AverageL=AverageL+LeftArray[ij];
	AverageR=AverageR+RightArray[ij];
	}
	motor[left] = AverageL/20;
	motor[right] = AverageR/20;
	//wait1Msec(10);
	for (int ik=1; ik<=19; ik++)	{ //shifts the array over by one
		LeftArray[ik+1]=LeftArray[ik];
		RightArray[ik+1]=RightArray[ik];
	}

	if(joystick.joy2_TopHat == 0){
		DriveEncReset();
		while(nMotorEncoder[left] < 70 && nMotorEncoder[right] < 70) {
			motor[left] = 17;
			motor[right] = 17;
		}
		motor[left] = 0;
		motor[right] = 0;
	}

	if(joystick.joy2_TopHat == 6){
		RightTurn ();
		Backwards ();
		LeftTurn ();
		Forwards ();
	}

	if(joystick.joy2_TopHat == 4){
		DriveEncReset();
		while(nMotorEncoder[left] > -45 && nMotorEncoder[right] > -45) {
			motor[left] = -17;
			motor[right] = -17;
		}
	}

	if(joystick.joy2_TopHat == 2){
		LeftTurn ();
		Backwards ();
		RightTurn ();
		Forwards ();
	}

	if(joy2Btn(1)) {
 }
}

void rampDeploy () {
//	if(joy2Btn(9) && joy2Btn(10)) // to prevent mistakenly activating, need to hold 2 buttons down together
//		servo[ramp] = 35;
}

void inverseKinematicsAndWristStabilization() {			// first, wrist stabilization
	thetaS = (-0.0416 * -nMotorEncoder[arm]) + 228;
	thetaTE = (-0.706*ServoValue[elbow])+210;
	thetaW = 360-thetaS-thetaTE;
	countW =-1.417*(thetaW-273);

	if (countW > 255)					// this section sets the position of the wrist based solely on the shoulder and elbow angles to keep basket level
		countW = 255;
	if(joy1Btn(5))
		servo[wrist]  = countW + 64;
	else
		servo[wrist]  =  countW;	// if user clicks button to disable stabilization, wrist set to be perpendicular to forearm
	// now we calculate the XY coordinates of the arm based on the shoulder and elbow angles (Forward Kinematics)

	xT = L1 * cosDegrees(thetaS) + L2 * cosDegrees(thetaTE + thetaS - 180);// angles in degrees
	yT = L1 * sinDegrees(thetaS) + L2 * sinDegrees(thetaTE + thetaS - 180);
																								// use joystick input to determine where to move. Assumes motion will continue based on magnitude of joystick entry until user halts
	if (abs(joystick.joy1_x2) < 10)								// ignore any joystick control entry less than 10 to avoid drift
		deltaX = 0;
	else
		deltaX = joystick.joy1_x2 * sensitivity;		//sensitivity is adjusted empirically

	if (abs(joystick.joy1_y2) < 10)
		deltaY = 0;
	else
		deltaY = joystick.joy1_y2 * sensitivity;
																								// now we have the deltas we want, use IK to move arm to next goal
	newX = xT + deltaX;
	if (newX < 0)																	// prevent from moving into -X territory as IK doesn't work in that area
		newX = 0;
	newY = yT + deltaY;
	if (newY < -11) 										//prevents from hitting the field
		newY = -11;
	if(joy1Btn(6)){											//enables automatic height position(middle rung)
		deltaY=0.5;
		deltaX=0.5;
		newY = 18;
		newX = 2;
	}
	if(joy1Btn(8)){											//lower rung
		deltaY=0.5;
		deltaX=0.5;
		newY = 2;
		newX = 2;
	}

	Pr = sqrt(newX * newX + newY * newY);
	thetaR = atan(newY / newX) * radToDeg;
	thetaA = acos((L2 * L2 - L1 * L1 - Pr * Pr) / (-2 * L1 * Pr)) * radToDeg;
																																								//	newThetaTE = asin((Pr * sinDegrees(thetaA)) / L2) * radToDeg; // this is wrong for angles greater than 90 due to limitation of the law of Sines
	newThetaTE = acos((L2 * L2 + L1 * L1 - Pr * Pr) / ( 2 * L1 * L2)) * radToDeg;	//so instead apply the law of cosines again since we know length of all 3 sides.
	newThetaS = thetaA + thetaR;

	deltaTE = newThetaTE - thetaTE; 							// this is to figure out how much rate change to apply. Bigger difference, more power/faster
	deltaS = newThetaS - thetaS;									// newThetaTE and newThetaS are our goals. Drive arm to move to those angles
																								// first do elbow
 	elbowPosition = -1.417 * (newThetaTE - 210);
 	if (elbowPosition<55)													// when elbow gets close to 180 degrees, IK needs it to move fast, but it jerks,
 		servoChangeRate[elbow] = 2;									// this smooths out last few inches of movement by slowing servo down
 	else
		servoChangeRate[elbow] = deltaTE*40; 				// otherwise need to adjust speed of elbow vs shoulder based on delta angles - range 1-10
	if (elbowPosition < 43)
		elbowPosition = 43;													// should put a limit on elbow position so it doesn't go beyond 180 degrees
	servo[elbow] = elbowPosition;
	nme=nMotorEncoder[arm];														//now shoulder - ideally would do together, but want to start elbow since it should continue and doesnt require while loop
	shoulderGoal = (24* (newThetaS-228))+(nme/625);  	// goal is in encoder counts. Key is must go correct direction or will never exit loop - new correction is 228 - was using 222, but remeasured.
	//there is an error that makes shoulder goal less negative than where the encoder thinks is it. Causes drift. Add to goal to get them
	// to be the same. Error= nme/625 - acquired empirically
	deltaEncoder=abs(nme-shoulderGoal);
	direction=nme-shoulderGoal;
	if (newX<1 && direction<0)
		deltaEncoder=deltaEncoder/4;								//as basket approaches 0, decrease motor power to prevent kick back but allow full power in other direction
	if ((nMotorEncoder[arm]<-500) && (nMotorEncoder[arm]>-7500)){	// safety precaution - prevents arm from moving too far left or right
		if(nMotorEncoder[arm] > shoulderGoal)
				motor[arm] = -deltaEncoder/2;
		if(nMotorEncoder[arm] < shoulderGoal)
				motor[arm] = deltaEncoder/2;
		if(deltaEncoder<1)
			motor[arm]=0;
	}
	else {
		motor[arm]=0;
		while(nMotorEncoder[arm] > -510) {
			motor[arm] = -25;
		}
		while(nMotorEncoder[arm] < -7400) {
			motor[arm] = 25;
		}
	}
}

task main()	{

	waitForStart(); 														  // wait for start of tele-op phase
	initializeRobot();
	while(true) {
		getJoystickSettings(joystick);							//gets value of all joystick variables. Executes each loop to get most recent values
		inverseKinematicsAndWristStabilization();		//controls all movements of the arm including wrist stabilization
		driveControl ();
		Pack();																			// activate at end to put arm away. Useful for testing.
		//rampDeploy();
		wait1Msec(50);															// change this to set the # of times the controller is sampled and motor events adjusted
	}
}
